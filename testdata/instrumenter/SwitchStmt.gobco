package instrumenter

func switchStmt(expr int, cond bool, s string) {

	switch {

	case gobcoCover(0, expr == 5):

	case gobcoCover(1, cond):

	}

	switch gobco0 := s; {
	case gobcoCover(2, gobco0 == "one"),
		gobcoCover(3, gobco0 == "two"),
		gobcoCover(4, gobco0 == "three"):
	}

	switch gobco1 := s + "suffix"; {
	case gobcoCover(5, gobco1 == "one"),
		gobcoCover(6, gobco1 == "two"),
		gobcoCover(7, gobco1 == ""+s):
	}
	switch {
	case true:

		s = "prefix" + s
		gobco2 := s + "suffix"
		switch {
		case gobcoCover(8, gobco2 == "prefix.a.suffix"):
		}
	}
	switch {
	case true:

		s := "prefix" + s
		gobco3 := s + "suffix"
		switch {
		case gobcoCover(9, gobco3 == "prefix.a.suffix"):
		}
	}

	switch s := "prefix" + s; {
	case gobcoCover(10, s == "one"):
	}
	switch {
	case true:

		a, b := (func() (string, string) { return "a", "b" })()
		gobco4 := cond
		switch {
		case gobcoCover(11, gobco4 == true):
			a += b
			b += a
		}
	}

	ch := make(chan<- int, 1)
	switch {
	case true:
		ch <- 3
		gobco5 := expr
		switch {
		case gobcoCover(12, gobco5 == 5):
		}
	}

}

// :14:7: "expr == 5"
// :16:7: "cond"
// :27:7: "s == \"one\""
// :28:3: "s == \"two\""
// :29:3: "s == \"three\""
// :36:7: "s + \"suffix\" == \"one\""
// :37:3: "s + \"suffix\" == \"two\""
// :38:3: "s + \"suffix\" == \"\" + s"
// :48:7: "s + \"suffix\" == \"prefix.a.suffix\""
// :53:7: "s + \"suffix\" == \"prefix.a.suffix\""
// :60:7: "s == \"one\""
// :68:7: "cond == true"
// :79:7: "expr == 5"
