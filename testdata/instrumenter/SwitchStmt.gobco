package instrumenter

func switchStmt(expr int, cond bool, s string) {

	_ = "no init; no tag"
	switch {
	case gobcoCover(0, expr == 5):
	case gobcoCover(1, cond):
	}

	_ = "no init; tag is an identifier"
	switch {
	default:
		gobco0 := s
		_ = gobco0
		switch {
		case gobcoCover(2, gobco0 == "one"),
			gobcoCover(3, gobco0 == "two"),
			gobcoCover(4, gobco0 == "three"):
		}
	}

	_ = "no init; tag is a complex expression"
	switch {
	default:
		gobco1 := s + "suffix"
		_ = gobco1
		switch {
		case gobcoCover(5, gobco1 == "one"),
			gobcoCover(6, gobco1 == "two"),
			gobcoCover(7, gobco1 == ""+s):
		}
	}

	_ = "init overwrites variable; tag uses the overwritten variable"
	switch {
	default:
		s = "prefix" + s
		gobco2 := s + "suffix"
		_ = gobco2
		switch {
		case gobcoCover(8, gobco2 == "prefix.a.suffix"):
		}
	}

	_ = "init defines new variable; tag uses the new variable"
	switch {
	default:
		s := "prefix" + s
		gobco3 := s + "suffix"
		_ = gobco3
		switch {
		case gobcoCover(9, gobco3 == "prefix.a.suffix"):
		}
	}

	_ = "init, but no tag"
	switch s := "prefix" + s; {
	case gobcoCover(10, s == "one"):
	case gobcoCover(11, cond):
	}

	_ = "init with multi-valued function call"
	switch {
	default:
		a, b := (func() (string, string) { return "a", "b" })()
		gobco4 := cond
		_ = gobco4
		switch {
		case gobcoCover(12, gobco4 == true):
			a += b
			b += a
		}
	}

	_ = "init with non-assignment"
	ch := make(chan<- int, 1)
	switch {
	default:
		ch <- 3
		gobco5 := expr
		_ = gobco5
		switch {
		case gobcoCover(13, gobco5 == 5):
		}
	}

	switch {
	default:
		a, b := cond, !gobcoCover(23, cond)
		gobco6 := cond
		_ = gobco6
		switch {
		case gobcoCover(14, gobco6 == a):
		case gobcoCover(15, gobco6 == !gobcoCover(24, a)):
		case gobcoCover(16, gobco6 == (!gobcoCover(25, a))):
		case gobcoCover(17, gobco6 == (gobcoCover(26, a) && gobcoCover(27, b))):
		case gobcoCover(18, gobco6 == (gobcoCover(28, a) && !gobcoCover(29, b))):
		case gobcoCover(19, gobco6 == (gobcoCover(30, a) || gobcoCover(31, b))):
		case gobcoCover(20, gobco6 == (!gobcoCover(33, a) || gobcoCover(32, b))):
		case gobcoCover(21, gobco6 == (a == b)):
		case gobcoCover(22, gobco6 == (a != b)):
		}
	}

	switch {
	default:
		gobco7 := gobcoCover(34, 1 > 0)
		_ = gobco7
		switch {
		}
	}

}

// :16:7: "expr == 5"
// :17:7: "cond"
// :30:7: "s == \"one\""
// :31:3: "s == \"two\""
// :32:3: "s == \"three\""
// :40:7: "s + \"suffix\" == \"one\""
// :41:3: "s + \"suffix\" == \"two\""
// :42:3: "s + \"suffix\" == \"\" + s"
// :53:7: "s + \"suffix\" == \"prefix.a.suffix\""
// :59:7: "s + \"suffix\" == \"prefix.a.suffix\""
// :67:7: "s == \"one\""
// :68:7: "cond"
// :79:7: "cond == true"
// :91:7: "expr == 5"
// :100:7: "cond == a"
// :101:7: "cond == !a"
// :102:7: "cond == (!a)"
// :103:7: "cond == (a && b)"
// :104:7: "cond == (a && !b)"
// :105:7: "cond == (a || b)"
// :106:7: "cond == (!a || b)"
// :107:7: "cond == (a == b)"
// :108:7: "cond == (a != b)"
// :99:24: "cond"
// :101:8: "a"
// :102:9: "a"
// :103:7: "a"
// :103:12: "b"
// :104:7: "a"
// :104:13: "b"
// :105:7: "a"
// :105:12: "b"
// :106:13: "b"
// :106:8: "a"
// :112:9: "1 > 0"
