package instrumenter

import (
	"reflect"
)

func typeSwitchStmt() {
}

func typeSwitchStmtScopes(value interface{}) string {

	switch v := value.(type) {

	case int, uint:

		return "integer " + reflect.TypeOf(v).String()

	case string:

		return "string " + reflect.TypeOf(v).String()

	case struct{}:
		return "struct{} " + reflect.TypeOf(v).String()

	case uint8:

		return "byte"

	default:
		return "other " + reflect.TypeOf(v).String()
	}
}

func typeSwitchStmtScopesInstrumented(value interface{}) string {

	switch tmp0 := value; {

	case gobcoCover(0, func() bool { _, ok := tmp0.(int); return ok }()),
		gobcoCover(1, func() bool { _, ok := tmp0.(uint); return ok }()):
		v := tmp0
		_ = v
		return "integer " + reflect.TypeOf(v).String()

	case gobcoCover(2, func() bool { _, ok := tmp0.(string); return ok }()):
		v := tmp0.(string)
		_ = v
		return "string " + reflect.TypeOf(v).String()

	case gobcoCover(3, func() bool { _, ok := tmp0.(struct{}); return ok }()):
		v := tmp0.(struct{})
		_ = v
		return "struct{} " + reflect.TypeOf(v).String()

	case gobcoCover(4, func() bool { _, ok := tmp0.(uint8); return ok }()):
		v := tmp0.(uint8)
		_ = v
		return "byte"

	default:
		v := tmp0
		return "other " + reflect.TypeOf(v).String()
	}
}

// :66:7: "func() bool { _, ok := tmp0.(int); return ok }()"
// :67:3: "func() bool { _, ok := tmp0.(uint); return ok }()"
// :72:7: "func() bool { _, ok := tmp0.(string); return ok }()"
// :77:7: "func() bool { _, ok := tmp0.(struct{}); return ok }()"
// :82:7: "func() bool { _, ok := tmp0.(uint8); return ok }()"
