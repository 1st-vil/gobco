package instrumenter

import (
	"reflect"
)

func typeSwitchStmt() {
}

func typeSwitchStmtScopes(value interface{}) string {

	switch _ = gobcoCover(0, 123 > 0); v := value.(type) {

	case int, uint:

		return "integer " + reflect.TypeOf(v).String()

	case string:

		return "string " + reflect.TypeOf(v).String()

	case struct{}:
		return "struct{} " + reflect.TypeOf(v).String()

	case uint8:

		return "byte"

	case nil:
		return "nil"

	default:
		return "other " + reflect.TypeOf(v).String()
	}
}

func typeSwitchStmtScopesInstrumented(value interface{}) string {

	switch interface{}(0).(type) {
	default:
		_ = gobcoCover(1, 123 > 0)
		tmp0 := value

		switch {

		case gobcoCover(2, func() bool { _, ok := tmp0.(int); return ok }()),
			gobcoCover(3, func() bool { _, ok := tmp0.(uint); return ok }()):
			v := tmp0
			_ = v
			return "integer " + reflect.TypeOf(v).String()

		case gobcoCover(4, func() bool { _, ok := tmp0.(string); return ok }()):
			v := tmp0.(string)
			_ = v
			return "string " + reflect.TypeOf(v).String()

		case gobcoCover(5, func() bool { _, ok := tmp0.(struct{}); return ok }()):
			v := tmp0.(struct{})
			_ = v
			return "struct{} " + reflect.TypeOf(v).String()

		case gobcoCover(6, func() bool { _, ok := tmp0.(uint8); return ok }()):
			v := tmp0.(uint8)
			_ = v
			return "byte"

		case gobcoCover(7, tmp0 == nil):
			return "nil"

		default:
			v := tmp0
			return "other " + reflect.TypeOf(v).String()
		}
	}
}

// :26:13: "123 > 0"
// :69:7: "123 > 0"
// :74:8: "func() bool { _, ok := tmp0.(int); return ok }()"
// :75:4: "func() bool { _, ok := tmp0.(uint); return ok }()"
// :80:8: "func() bool { _, ok := tmp0.(string); return ok }()"
// :85:8: "func() bool { _, ok := tmp0.(struct{}); return ok }()"
// :90:8: "func() bool { _, ok := tmp0.(uint8); return ok }()"
// :95:8: "tmp0 == nil"
