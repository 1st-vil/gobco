package instrumenter

import (
	"reflect"
)

// https://go.dev/ref/spec#Type_switches

// typeSwitchStmt covers the instrumentation of [ast.TypeSwitchStmt], which
// has no expression fields.
//
// A type switch statement contains implicit comparisons that need to be
// instrumented.
func typeSwitchStmt(tag interface{}, value interface{}) string {

	// The type switch guard can be a simple expression.
	{
		_ = tag
		switch {
		}
	}

	// The type switch guard can be a short variable declaration for a
	// single variable, in which case each branch gets its own declared
	// variable, with the proper type.
	{
		gobco1 := tag
		switch {
		default:
			v := gobco1
			_ = v

			_ = v
		}
	}

	// A type switch statement may have an initialization statement that is
	// evaluated in a nested scope. The type switch tag can be a short
	// variable definition, which has another, nested scope, in each of the
	// case clauses.
	switch tag := tag; {
	default:
		gobco2 := tag
		switch {
		default:
			tag := gobco2
			_ = tag

			_ = tag
		}
	}

	// Type expressions may be parenthesized:
	{
		gobco3 := tag
		_, gobco4 := gobco3.((int))
		switch {
		case gobcoCover(0, gobco4):
			return "parenthesized " + reflect.TypeOf(tag).Name()
		}
	}

	{
		gobco5 := tag
		gobco6 := gobco5 == nil
		switch {
		case gobcoCover(1, gobco6):
			return "nil"
		}
	}

	// In case clauses with a single type, the variable has that type.
	// In all other cases, the variable has the type of the guard expression.
	// The type identifier 'nil' matches a nil interface value.
	{
		gobco7 := tag
		_, gobco8 := gobco7.(uint)
		_, gobco9 := gobco7.(uint8)
		_, gobco10 := gobco7.(uint16)
		gobco11 := gobco7 == nil
		switch {
		case gobcoCover(2, gobco8):
			v := gobco7.(uint)
			_ = v

			_ = v + uint(0)
			return "uint " + reflect.TypeOf(v).Name()
		case gobcoCover(3, gobco9), gobcoCover(4, gobco10):
			v := gobco7
			_ = v

			return "any " + reflect.TypeOf(v).Name()
		case gobcoCover(5, gobco11):
			v := gobco7
			_ = v

			// unreachable
			return "nil " + reflect.TypeOf(v).Name()
		}
	}

	// TODO: Test type parameters and generic types.

	switch _ = gobcoCover(12, 123 > 0); {
	default:
		gobco12 := value
		_, gobco13 := gobco12.(int)
		_, gobco14 := gobco12.(uint)
		_, gobco15 := gobco12.(string)
		_, gobco16 := gobco12.(struct{})
		_, gobco17 := gobco12.(uint8)
		gobco18 := gobco12 == nil
		switch {

		case gobcoCover(6, gobco13), gobcoCover(7, gobco14):
			v := gobco12
			_ = v

			// In a clause that lists multiple types, the expression 'v' has the
			// type of the switch tag, in this case 'interface{}'.
			return "integer " + reflect.TypeOf(v).String()

		case gobcoCover(8, gobco15):
			v := gobco12.(string)
			_ = v

			// In a clause that lists a single type, the expression 'v' has the
			// type from the case clause.
			return "string " + reflect.TypeOf(v).String()

		case gobcoCover(9, gobco16):
			v := gobco12.(struct{})
			_ = v

			return "struct{} " + reflect.TypeOf(v).String()

		case gobcoCover(10, gobco17):
			v := gobco12.(uint8)
			_ = v

			// The variable 'v' may be unused in some of the case clauses.
			return "byte"

		case gobcoCover(11, gobco18):
			v := gobco12
			_ = v

			return "nil"

		default:
			v := gobco12
			_ = v

			return "other " + reflect.TypeOf(v).String()
		}
	}

}

// :39:7: "tag.(type) == (int)"
// :44:7: "tag.(type) == nil"
// :52:7: "tag.(type) == uint"
// :55:7: "tag.(type) == uint8"
// :55:14: "tag.(type) == uint16"
// :57:7: "tag.(type) == nil"
// :66:7: "value.(type) == int"
// :66:12: "value.(type) == uint"
// :71:7: "value.(type) == string"
// :76:7: "value.(type) == (struct{})"
// :79:7: "value.(type) == uint8"
// :83:7: "value.(type) == nil"
// :64:13: "123 > 0"
